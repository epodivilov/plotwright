#!/usr/bin/env node

const path = require('path');
const fs = require('fs/promises');
const { spawn } = require('child_process');
const { existsSync } = require('fs');
const mb = require('mountebank');
const tmp = require("tmp");
const http = require('http');
const { Transform } = require('stream')

class Filter extends Transform {

  constructor() {
    super({
      readableObjectMode: true,
      writableObjectMode: true
    })
  }

  _transform(chunk, encoding, next) {
    if (this.has(chunk)) {
      return next(null, chunk)
    }

    next()
  }

  has(value) {
    return ['To open last HTML report run:', 'show-report']
      .every(it => value.toString().includes(it) === false)
  }
}

function curl(options, method, path, body) {
  return new Promise((resolve, reject) => {
    const requestOptions = {
      method: method,
      path: path,
      port: options.port,
      hostname: options.host || 'localhost',
      headers: {
        'Content-Type': 'application/json',
        Connection: 'close'
      }
    };

    if (options.apikey) {
      requestOptions.headers['x-api-key'] = options.apikey;
    }

    const request = http.request(requestOptions, response => {
      response.body = '';
      response.setEncoding('utf8');
      response.on('data', chunk => { response.body += chunk; });
      response.on('end', () => {
        if (response.statusCode === 200) {
          response.body = JSON.parse(response.body);
          resolve(response);
        }
        else {
          reject(new Error(`${response.statusCode}\n${response.body}`));
        }
      });
    });

    request.on('error', reject);

    if (body) {
      request.write(JSON.stringify(body, null, 2));
    }
    request.end();
  });
}

const argv = require('minimist')(process.argv.slice(2));
const command = argv['_'][0];

const configFile = argv.config || path.join(process.cwd(), 'plotwright.config.js');

if (!existsSync(configFile)) {
  console.error(`Config file not found: ${configFile}`);
  process.exit(1);
}

function log(message) {
  process.stdout.clearLine(0);
  process.stdout.cursorTo(0);
  process.stdout.write(message);
}

async function pause(delay) {
  return new Promise(resolve => setTimeout(resolve, delay))
}

async function startMountebank({ imposters, logDir }) {
  // –°–æ–∑–¥–∞–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é —Å–µ—Ä–≤–µ—Ä–∞ Mountebank
  const mbOptions = {
    port: 2525, // –ø–æ—Ä—Ç —Å–µ—Ä–≤–µ—Ä–∞ Mountebank
    allowInjection: true, // —Ä–∞–∑—Ä–µ—à–∏—Ç—å –∏–Ω—ä–µ–∫—Ü–∏–∏ –∫–æ–¥–∞ –≤ –∏–º–ø–æ—Å—Ç–µ—Ä–æ–≤,
    log: {
      transports: {
        file: {
          path: path.resolve(process.cwd(), logDir, 'mountebank.log'),
          format: 'json'
        }
      }
    }
  };

  log(`Mountebank: starting üîÑ`);
  const { close } = await mb.create(mbOptions);

  log(`Mountebank: loading imposters üîÑ`);
  const body = await Promise.all(imposters.map(async (path) => {
    const data = await fs.readFile(path, 'utf-8');
    return JSON.parse(data);
  }))

  await curl(mbOptions, 'PUT', '/imposters', {
    imposters: body
  });
  log(`Mountebank: started ‚úÖ\n`)

  return (onClose) => new Promise((resolve) => {
    log(`Mountebank: stopping üîÑ`)
    return close(() => {
      log(`Mountebank: stopped ‚úÖ\n`)
      if (typeof onClose === 'function') {
        onClose();
      }
      resolve();
    });
  })
}

async function startPlaywright({ logDir, outputFolder, headless = true, command, testDir }) {
  log(`Playwright: preparing üîÑ`);
  const playwrightConfig = tmp.fileSync({ name: 'playwright.config.ts', tmpdir: logDir })
  await fs.writeFile(playwrightConfig.name, `
  import pkg from "${path.join(__dirname, '../node_modules/@playwright/test/index.js')}";
  const { defineConfig, devices } = pkg;
  export default defineConfig({
    testDir: "${path.resolve(process.cwd(), testDir)}",
    fullyParallel: true,
    forbidOnly: !!process.env.CI,
    retries: process.env.CI ? 2 : 0,
    workers: process.env.CI ? 1 : undefined,
    reporter: [['list'], ["html", { outputFolder: "${path.resolve(process.cwd(), outputFolder)}", open: "never" }]],
    outputDir: "./test-results",
    use: {
      baseURL: 'http://localhost:${process.env.PORT}',
      trace: "on",
      headless: ${headless},
      ${headless === false ? `launchOptions: {
        slowMo: 2000,
        devtools: true,
      },`: ''}
    },
    projects: [
      {
        name: "chromium",
        use: { ...devices["Desktop Chrome"] },
      },
    ],
    webServer: {
      command: '${command}',
      url: 'http://localhost:${process.env.PORT}',
      reuseExistingServer: !process.env.CI,
    },
  });`);

  return new Promise((resolve) => {
    log(`Playwright: starting üîÑ`);
    const playwrightExecutable = path.join(__dirname, '../node_modules/.bin/playwright');
    const playwright = spawn('node', [playwrightExecutable, 'test', '--config', playwrightConfig.name]);
    log(`Playwright: started ‚úÖ\n`);

    const transformer = new Filter()
    playwright.stdout.pipe(transformer).pipe(process.stdout);
    playwright.stderr.pipe(process.stderr);

    playwright.on('exit', (code) => {
      log(`Playwright: finished ${code !== 0 ? '‚ùå' : '‚úÖ'}\n`);
      return resolve(code);
    });
  })
}

async function showPlaywrightReport({ outputFolder }) {
  return new Promise((resolve) => {
    const reportDir = path.resolve(process.cwd(), outputFolder);
    const playwrightExecutable = path.join(__dirname, '../node_modules/.bin/playwright');
    const playwright = spawn('node', [playwrightExecutable, 'show-report', reportDir]);
    playwright.stdout.pipe(process.stdout);
    playwright.stderr.pipe(process.stderr);
    playwright.on('exit', resolve);
  })
}

(async () => {
  const { mountebank, playwright } = await import(configFile).then((module) => module.default);

  if (command === 'test') {
    let logDir
    try {
      logDir = tmp.dirSync({ name: '.tmp', tmpdir: '.', unsafeCleanup: true });
    } catch (error) {
      console.error("‚ö†Ô∏è", "–ö–∞–∂–µ—Ç—Å—è –ø—Ä–æ—à–ª—ã–π –∑–∞–ø—É—Å–∫ –±—ã–ª –Ω–µ —É–¥–∞—á–Ω—ã–π. –ï—Å–ª–∏ –≤—ã —É–∂–µ –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–ª–∏ –ª–æ–≥–∏ —Ç–æ —É–¥–∞–ª–∏—Ç–µ –ø–∞–ø–∫—É .tmp –≤ –∫–æ—Ä–Ω–µ –ø—Ä–æ–µ–∫—Ç–∞")
      process.exit(1);
    }

    const stopMountebank = await startMountebank({ ...mountebank, logDir: logDir.name });

    const code = await startPlaywright({ ...playwright, logDir: logDir.name });
    await stopMountebank();

    if (code === 0) {
      logDir.removeCallback();
    }

    process.exit(code);
  }

  if (command === 'report') {
    await showPlaywrightReport(playwright)
  }
})()
