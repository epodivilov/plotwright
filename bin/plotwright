#!/usr/bin/env node

const path = require("path");
const fs = require("fs/promises");
const { spawn } = require("child_process");
const { existsSync } = require("fs");
const mb = require("mountebank");
const tmp = require("tmp");
const http = require("http");
const { Transform } = require("stream");

class Filter extends Transform {
  constructor() {
    super({
      readableObjectMode: true,
      writableObjectMode: true,
    });
  }

  _transform(chunk, encoding, next) {
    if (this.has(chunk)) {
      return next(null, chunk);
    }

    next();
  }

  has(value) {
    return ["To open last HTML report run:", "show-report"].every((it) => value.toString().includes(it) === false);
  }
}

function curl(options, method, path, body) {
  return new Promise((resolve, reject) => {
    const requestOptions = {
      method: method,
      path: path,
      port: options.port,
      hostname: options.host || "localhost",
      headers: {
        "Content-Type": "application/json",
        Connection: "close",
      },
    };

    if (options.apikey) {
      requestOptions.headers["x-api-key"] = options.apikey;
    }

    const request = http.request(requestOptions, (response) => {
      response.body = "";
      response.setEncoding("utf8");
      response.on("data", (chunk) => {
        response.body += chunk;
      });
      response.on("end", () => {
        if (response.statusCode === 200) {
          response.body = JSON.parse(response.body);
          resolve(response);
        } else {
          reject(new Error(`${response.statusCode}\n${response.body}`));
        }
      });
    });

    request.on("error", reject);

    if (body) {
      request.write(JSON.stringify(body, null, 2));
    }
    request.end();
  });
}

const argv = require("minimist")(process.argv.slice(2));
const command = argv["_"][0];

const configFile = argv.config || path.join(process.cwd(), "plotwright.config.js");

if (!existsSync(configFile)) {
  console.error(`Config file not found: ${configFile}`);
  process.exit(1);
}

function log(message) {
  process.stdout.clearLine(0);
  process.stdout.cursorTo(0);
  process.stdout.write(message);
}

async function pause(delay) {
  return new Promise((resolve) => setTimeout(resolve, delay));
}

async function startMountebank({ logDir, logLevel, imposters = [], ...config }) {
  const mbOptions = {
    port,
    allowInjection: true,
    log: {
      level: logLevel,
      transports: {
        file: {
          path: path.resolve(process.cwd(), logDir, "mountebank.log"),
          format: "json",
        },
      },
    },
    ...config,
  };

  log(`Mountebank: starting üîÑ`);
  const { close } = await mb.create(mbOptions);

  if (imposters.length > 0) {
    log(`Mountebank: loading imposters üîÑ`);
    const body = await Promise.all(
      imposters.map(async (path) => {
        const data = await fs.readFile(path, "utf-8");
        return JSON.parse(data);
      })
    );

    await curl(mbOptions, "PUT", "/imposters", {
      imposters: body,
    });
  }
  log(`Mountebank: started ‚úÖ\n`);

  return (onClose) =>
    new Promise((resolve) => {
      log(`Mountebank: stopping üîÑ`);
      return close(() => {
        log(`Mountebank: stopped ‚úÖ\n`);
        if (typeof onClose === "function") {
          onClose();
        }
        resolve();
      });
    });
}

async function startPlaywright({ logDir, ...config }) {
  log(`Playwright: preparing üîÑ`);
  const playwrightConfig = tmp.fileSync({ name: "playwright.config.ts", tmpdir: logDir });

  await fs.writeFile(
    playwrightConfig.name,
    `import { defineConfig, devices } from "plotwright";
  export default defineConfig(${JSON.stringify(config, null, 2)});`
  );

  return new Promise((resolve) => {
    log(`Playwright: starting üîÑ`);
    const playwrightExecutable = path.join(__dirname, "../node_modules/.bin/playwright");
    const playwright = spawn("node", [playwrightExecutable, "test", "--config", playwrightConfig.name]);
    log(`Playwright: started ‚úÖ\n`);

    const transformer = new Filter();
    playwright.stdout.pipe(transformer).pipe(process.stdout);
    playwright.stderr.pipe(process.stderr);

    playwright.on("exit", (code) => {
      log(`Playwright: finished ${code !== 0 ? "‚ùå" : "‚úÖ"}\n`);
      log(`To open last HTML report run "report" command\n`);
      return resolve(code);
    });
  });
}

async function showPlaywrightReport({ outputFolder }) {
  return new Promise((resolve) => {
    const reportDir = path.resolve(process.cwd(), outputFolder);
    const playwrightExecutable = path.join(__dirname, "../node_modules/.bin/playwright");
    const playwright = spawn("node", [playwrightExecutable, "show-report", reportDir]);
    playwright.stdout.pipe(process.stdout);
    playwright.stderr.pipe(process.stderr);
    playwright.on("exit", resolve);
  });
}

(async () => {
  const { mountebank, playwright } = await import(configFile).then((module) => module.default);

  if (command === "test") {
    let logDir;
    try {
      logDir = tmp.dirSync({ name: ".tmp", tmpdir: ".", unsafeCleanup: true });
    } catch (error) {
      console.error(
        "‚ö†Ô∏è",
        "It looks like the last launch was not successful. If you have already analyzed the logs, then delete the .tmp folder in the project root"
      );
      process.exit(1);
    }

    const stopMountebank = await startMountebank({ ...mountebank, logDir: logDir.name });

    const code = await startPlaywright({ ...playwright, logDir: logDir.name });
    await stopMountebank();

    if (code === 0) {
      logDir.removeCallback();
    }

    process.exit(code);
  }

  if (command === "report") {
    await showPlaywrightReport(playwright);
  }
})();
